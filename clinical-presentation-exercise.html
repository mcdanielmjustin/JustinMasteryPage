<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Patient Encounter â€” Mastery Page</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       DESIGN TOKENS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    :root {
      --bg:           #09090b;
      --bg2:          #0c0c0e;
      --bg3:          #121214;
      --surface:      #13131a;
      --surface2:     #1a1a24;
      --accent:       #6366f1;
      --accent-light: #818cf8;
      --accent-dark:  #4f46e5;
      --accent-glow:  rgba(99,102,241,0.18);
      --accent-ring:  rgba(99,102,241,0.25);
      --green:        #34d399;
      --green-bg:     rgba(52,211,153,0.08);
      --green-ring:   rgba(52,211,153,0.3);
      --red:          #f87171;
      --red-bg:       rgba(248,113,113,0.08);
      --red-ring:     rgba(248,113,113,0.25);
      --orange:       #fb923c;
      --blue:         #60a5fa;
      --purple:       #a78bfa;
      --gold:         #d4a054;
      --text:         #fafafa;
      --text2:        #a8a8b3;
      --text3:        #6b6b76;
      --border:       rgba(255,255,255,0.07);
      --border2:      rgba(255,255,255,0.04);
    }

    html, body {
      min-height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', system-ui, sans-serif;
      font-size: 15px;
      line-height: 1.6;
      overflow-x: hidden;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       KEYFRAME ANIMATIONS  (all defined here for all chunks)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* â”€â”€ Utility â”€â”€ */
    @keyframes spin         { to { transform: rotate(360deg); } }
    @keyframes pulse        { 0%,100%{opacity:.08;} 50%{opacity:.15;} }
    @keyframes fadeInUp     { from{opacity:0;transform:translateY(14px);} to{opacity:1;transform:none;} }
    @keyframes fadeIn       { from{opacity:0;} to{opacity:1;} }
    @keyframes shimmer      { 0%{background-position:-400px 0;} 100%{background-position:400px 0;} }

    /* â”€â”€ Answer feedback â”€â”€ */
    @keyframes correctPulse { 0%,100%{box-shadow:0 0 0 0 rgba(52,211,153,0);} 50%{box-shadow:0 0 0 8px rgba(52,211,153,.28);} }
    @keyframes wrongShake   { 0%,100%{transform:translateX(0);} 20%,60%{transform:translateX(-6px);} 40%,80%{transform:translateX(6px);} }

    /* â”€â”€ Encounter â”€â”€ */
    @keyframes phaseSlideIn  { from{opacity:0;transform:translateY(18px);} to{opacity:1;transform:none;} }
    @keyframes questionSlide { from{opacity:0;transform:scale(.96);} to{opacity:1;transform:scale(1);} }
    @keyframes tagPop        { 0%{transform:scale(0);opacity:0;} 60%{transform:scale(1.08);} 100%{transform:scale(1);opacity:1;} }
    @keyframes chartReveal   { from{opacity:0;transform:translateX(-8px);} to{opacity:1;transform:none;} }
    @keyframes pop           { 0%{transform:scale(.6);opacity:0;} 70%{transform:scale(1.06);} 100%{transform:scale(1);opacity:1;} }

    /* â”€â”€ Speech bubble â”€â”€ */
    @keyframes dotBlink      { 0%,80%,100%{opacity:0;} 40%{opacity:1;} }
    @keyframes bubbleIn      { from{opacity:0;transform:translateY(8px) scale(.97);} to{opacity:1;transform:none;} }

    /* â”€â”€ Score ring â”€â”€ */
    @keyframes scoreRingFill {
      from { stroke-dashoffset: var(--ring-full, 314); }
      to   { stroke-dashoffset: var(--ring-offset, 0); }
    }

    /* â”€â”€ Avatar: body states â”€â”€ */
    @keyframes breathe      { 0%,100%{transform:scaleY(1.000);} 50%{transform:scaleY(1.012);} }
    @keyframes breatheFast  { 0%,100%{transform:scaleY(1.000);} 50%{transform:scaleY(1.020);} }
    @keyframes postureBow   { from{transform:translateY(0) rotate(0deg);} to{transform:translateY(4px) rotate(-3deg);} }

    /* â”€â”€ Avatar: head/face â”€â”€ */
    @keyframes jawSpeak     { 0%,100%{transform:translateY(0);} 50%{transform:translateY(3px);} }
    @keyframes headTilt     { 0%,100%{transform:rotate(0deg);} 50%{transform:rotate(-6deg);} }
    @keyframes microShake   { 0%,100%{transform:translateX(0);} 25%{transform:translateX(-2px);} 75%{transform:translateX(2px);} }
    @keyframes gazeAvert    { 0%,100%{transform:translateX(0);} 50%{transform:translateX(-5px);} }

    /* â”€â”€ Avatar: hands/body â”€â”€ */
    @keyframes fidgetHand   { 0%,100%{transform:rotate(0deg);} 30%{transform:rotate(-4deg);} 70%{transform:rotate(4deg);} }

    /* â”€â”€ Avatar: tearful â”€â”€ */
    @keyframes tearFall     { 0%{opacity:0;transform:translateY(0);} 20%{opacity:.85;} 100%{opacity:0;transform:translateY(28px);} }

    /* â”€â”€ Auto-advance bar â”€â”€ */
    @keyframes autoAdvance  { from{width:0%;} to{width:100%;} }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       AVATAR STATE CLASSES  (applied to #avatar-root)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .state-idle       #avatar-body  { animation: breathe 4s ease-in-out infinite; }
    .state-speaking   #avatar-jaw   { animation: jawSpeak .32s ease-in-out infinite; }
    .state-speaking   #avatar-body  { animation: breathe 3s ease-in-out infinite; }
    .state-distressed #avatar-body  { animation: postureBow .8s ease forwards, breathe 5s ease-in-out infinite .8s; }
    .state-tearful    #avatar-tear  { animation: tearFall 2.4s ease-in-out infinite; }
    .state-tearful    #avatar-body  { animation: breathe 6s ease-in-out infinite; }
    .state-anxious    #avatar-body  { animation: breatheFast 1.8s ease-in-out infinite; }
    .state-anxious    #avatar-hand  { animation: fidgetHand .65s ease-in-out infinite alternate; }
    .state-agitated   #avatar-head  { animation: microShake .42s ease-in-out infinite; }
    .state-agitated   #avatar-body  { animation: breatheFast 1.2s ease-in-out infinite; }
    .state-guarded    #avatar-eyes  { animation: gazeAvert 3.2s ease-in-out infinite; }
    .state-guarded    #avatar-body  { animation: breathe 5s ease-in-out infinite; }
    .state-flat_affect #avatar-body { animation: breathe 8s ease-in-out infinite; }
    .state-confused   #avatar-head  { animation: headTilt 2.2s ease-in-out infinite; }
    .state-hopeful    #avatar-body  { animation: breathe 3.5s ease-in-out infinite; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       AMBIENT BLOBS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .blob {
      position: fixed; border-radius: 50%;
      filter: blur(120px); pointer-events: none;
      animation: pulse 7s ease-in-out infinite; z-index: 0;
    }
    .blob-a { width: 560px; height: 560px; background: #6366f1; top: -220px; right: -180px; }
    .blob-b { width: 440px; height: 440px; background: #4f46e5; bottom: -140px; left: -120px; animation-delay: 3.5s; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       NAV
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    nav {
      position: sticky; top: 0; z-index: 100;
      height: 58px;
      background: rgba(9,9,11,0.88);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      display: flex; align-items: center;
      padding: 0 20px; gap: 12px;
    }
    .back-btn {
      display: flex; align-items: center; gap: 6px;
      font-size: 13px; font-weight: 500;
      color: var(--text3); text-decoration: none;
      transition: color .2s; flex-shrink: 0;
    }
    .back-btn:hover { color: var(--accent-light); }
    .nav-sep  { width: 1px; height: 18px; background: var(--border); flex-shrink: 0; }
    .nav-logo { display: flex; align-items: center; gap: 8px; text-decoration: none; flex-shrink: 0; }
    .logo-icon {
      width: 28px; height: 28px; border-radius: 6px;
      background: linear-gradient(135deg, var(--accent-light), var(--accent));
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 13px; color: #fff;
    }
    .logo-title { font-weight: 700; font-size: 14px; }
    .nav-right { margin-left: auto; display: flex; align-items: center; gap: 10px; }
    .nav-progress {
      font-size: 12px; font-weight: 600; color: var(--text3);
      letter-spacing: .04em; display: none;
    }
    .nav-progress.visible { display: block; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN SYSTEM
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .screen { position: relative; z-index: 1; display: none; }
    .screen.active { display: block; }
    .screen.fading-out { opacity: 0; transition: opacity .35s ease; pointer-events: none; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN â€” LOADING
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #screen-loading.active {
      display: flex; align-items: center; justify-content: center;
      min-height: calc(100vh - 58px);
      padding: 24px;
    }

    .loader-card {
      display: flex; flex-direction: column; align-items: center; gap: 18px;
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 20px; padding: 44px 52px;
      max-width: 360px; width: 100%;
      animation: fadeInUp .5s ease-out both;
    }
    .loader-module-icon {
      font-size: 38px; line-height: 1; margin-bottom: 2px;
      filter: drop-shadow(0 0 18px rgba(99,102,241,.4));
    }
    .loader-spinner {
      width: 36px; height: 36px;
      border: 3px solid rgba(99,102,241,.18);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin .72s linear infinite;
    }
    .loader-status {
      font-size: 14px; font-weight: 600; color: var(--text2);
      text-align: center; min-height: 20px;
      transition: color .3s;
    }
    .loader-status.error { color: var(--red); }
    .loader-bar-track {
      width: 100%; height: 4px;
      background: rgba(255,255,255,.06);
      border-radius: 2px; overflow: hidden;
    }
    .loader-bar-fill {
      height: 100%; background: var(--accent); border-radius: 2px;
      transition: width .4s ease; width: 0%;
    }
    .loader-detail {
      font-size: 12px; color: var(--text3);
      text-align: center; min-height: 18px;
    }
    .loader-back {
      display: none; font-size: 13px; font-weight: 600;
      color: var(--accent-light); text-decoration: none;
      border: 1px solid var(--accent-ring); border-radius: 8px;
      padding: 8px 20px; transition: background .2s;
    }
    .loader-back:hover { background: var(--accent-glow); }
    .loader-back.visible { display: inline-block; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN â€” ENCOUNTER  (populated in Chunk 3 & 4)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #screen-encounter.active { display: block; min-height: calc(100vh - 58px); }

    /* Encounter layout skeleton â€” populated by Chunk 4 */
    .encounter-layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      grid-template-rows: 1fr auto;
      gap: 0;
      min-height: calc(100vh - 58px);
      max-width: 1100px;
      margin: 0 auto;
      padding: 0;
      position: relative;
    }

    /* Patient stage â€” left column */
    .patient-stage {
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      padding: 32px 28px 24px;
      position: relative;
      border-right: 1px solid var(--border);
    }

    /* Chart panel â€” right column */
    .chart-panel {
      display: flex; flex-direction: column;
      background: var(--surface);
      border-left: 1px solid var(--border);
      overflow: hidden;
    }
    .chart-header {
      display: flex; align-items: center; gap: 10px;
      padding: 16px 20px; border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .chart-title {
      font-size: 12px; font-weight: 700;
      letter-spacing: .08em; text-transform: uppercase;
      color: var(--text3);
    }
    .chart-body {
      flex: 1; overflow-y: auto; padding: 14px 0 20px;
      scrollbar-width: thin; scrollbar-color: rgba(255,255,255,.08) transparent;
    }
    .chart-section { margin-bottom: 16px; }
    .chart-section-label {
      font-size: 9px; font-weight: 700; letter-spacing: .12em;
      text-transform: uppercase; color: var(--text3);
      padding: 0 20px 6px; border-bottom: 1px solid var(--border2);
      margin-bottom: 6px;
    }
    .chart-row {
      display: flex; gap: 10px;
      padding: 5px 20px; font-size: 12px; line-height: 1.45;
      animation: chartReveal .35s ease forwards;
      opacity: 0;
    }
    .chart-key {
      color: var(--text3); flex-shrink: 0;
      min-width: 80px; font-weight: 500;
    }
    .chart-val { color: var(--text2); }

    /* Phase controls â€” full-width bottom row */
    .phase-controls {
      grid-column: 1 / -1;
      display: flex; align-items: center; justify-content: space-between;
      padding: 14px 24px;
      border-top: 1px solid var(--border);
      background: var(--surface);
      position: relative;
    }
    .phase-indicator { display: flex; align-items: center; gap: 14px; }
    .phase-num {
      font-size: 12px; font-weight: 700;
      letter-spacing: .06em; text-transform: uppercase;
      color: var(--accent-light);
    }
    .phase-dots { display: flex; align-items: center; gap: 6px; }
    .phase-dot {
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--border); transition: background .25s;
    }
    .phase-dot.done    { background: var(--accent-dark); }
    .phase-dot.current { background: var(--accent-light); width: 8px; height: 8px; }

    /* Advance button */
    .btn-advance {
      display: flex; align-items: center; gap: 8px;
      background: var(--accent); color: #fff;
      font-family: inherit; font-size: 14px; font-weight: 700;
      border: none; border-radius: 10px; padding: 10px 22px;
      cursor: pointer; transition: background .2s, transform .15s;
    }
    .btn-advance:hover { background: var(--accent-light); transform: translateY(-1px); }
    .btn-advance:active { transform: none; }
    .btn-advance.hidden { display: none; }

    /* Auto-advance progress bar */
    .auto-bar {
      position: absolute; bottom: 0; left: 0; right: 0;
      height: 3px; background: transparent; overflow: hidden; display: none;
    }
    .auto-bar.running { display: block; }
    .auto-bar-fill {
      height: 100%; background: var(--accent);
      width: 0%; animation: none;
    }

    /* Patient info bar */
    .patient-info-bar {
      display: flex; align-items: center; gap: 12px;
      padding: 10px 16px;
      background: rgba(255,255,255,.025);
      border: 1px solid var(--border);
      border-radius: 10px; margin-bottom: 20px;
      width: 100%; max-width: 420px;
    }
    .patient-label { font-size: 13px; font-weight: 600; color: var(--text); }
    .patient-setting { font-size: 11px; color: var(--text3); }
    .patient-info-sep { width: 1px; height: 16px; background: var(--border); }

    /* Speech bubble */
    .speech-bubble {
      position: relative;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--border);
      border-radius: 16px 16px 16px 4px;
      padding: 14px 18px;
      max-width: 380px; width: 100%;
      margin-bottom: 16px;
      min-height: 60px;
      animation: bubbleIn .3s ease-out;
    }
    .speech-bubble.hidden { display: none; }
    .bubble-tail {
      position: absolute; bottom: -8px; left: 18px;
      width: 14px; height: 8px;
      background: rgba(255,255,255,.05);
      clip-path: polygon(0 0, 100% 0, 50% 100%);
    }
    .clinician-probe {
      font-size: 11px; font-style: italic; color: var(--text3);
      margin-bottom: 8px; display: none;
    }
    .clinician-probe.visible { display: block; }
    .bubble-dots { display: flex; align-items: center; gap: 4px; padding: 4px 0; }
    .bubble-dots span {
      width: 6px; height: 6px; background: var(--text3); border-radius: 50%;
      animation: dotBlink 1.2s ease-in-out infinite;
    }
    .bubble-dots span:nth-child(2) { animation-delay: .2s; }
    .bubble-dots span:nth-child(3) { animation-delay: .4s; }
    .bubble-dots.hidden { display: none; }
    .bubble-text { font-size: 13px; color: var(--text2); line-height: 1.6; }

    /* Behavioral tags overlay */
    .tag-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 60px;
      pointer-events: none;
      overflow: hidden;
    }
    .behavior-tag {
      position: absolute;
      font-size: 10px; font-weight: 700; letter-spacing: .04em;
      padding: 4px 10px; border-radius: 20px;
      animation: tagPop .32s cubic-bezier(.34,1.56,.64,1) forwards;
      opacity: 0;
      white-space: nowrap;
    }
    .tag-red    { background: rgba(248,113,113,.15); color: var(--red);    border: 1px solid rgba(248,113,113,.3); }
    .tag-orange { background: rgba(251,146,60,.15);  color: var(--orange); border: 1px solid rgba(251,146,60,.3); }
    .tag-blue   { background: rgba(96,165,250,.15);  color: var(--blue);   border: 1px solid rgba(96,165,250,.3); }
    .tag-purple { background: rgba(167,139,250,.15); color: var(--purple); border: 1px solid rgba(167,139,250,.3); }

    /* Avatar container */
    .avatar-wrap {
      width: 200px; height: 320px;
      position: relative; flex-shrink: 0;
    }
    #avatar-root {
      width: 100%; height: 100%;
      overflow: visible;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN â€” QUESTION  (populated in Chunk 5)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #screen-question.active {
      display: flex; flex-direction: column;
      min-height: calc(100vh - 58px);
      padding: 28px 24px 60px;
    }

    .question-wrap {
      max-width: 720px; width: 100%; margin: 0 auto;
      display: flex; flex-direction: column; gap: 20px;
      animation: questionSlide .35s ease both;
    }

    /* Question header row */
    .q-header {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .q-type-badge {
      font-size: 10px; font-weight: 700; letter-spacing: .08em;
      text-transform: uppercase; padding: 4px 10px; border-radius: 6px;
      border: 1px solid transparent;
    }
    .q-encounter-counter {
      font-size: 12px; font-weight: 600; color: var(--text3);
      margin-left: auto;
    }
    .q-multi-indicator {
      font-size: 11px; font-weight: 600; color: var(--text3);
      background: rgba(255,255,255,.04); border: 1px solid var(--border);
      border-radius: 6px; padding: 3px 9px; display: none;
    }
    .q-multi-indicator.visible { display: inline-block; }

    /* Question prompt */
    .q-prompt {
      font-family: 'Instrument Serif', Georgia, serif;
      font-size: 1.25rem; line-height: 1.45; color: var(--text);
    }

    /* Answer options */
    .options-grid { display: flex; flex-direction: column; gap: 10px; }
    .option-btn {
      display: flex; align-items: flex-start; gap: 14px;
      background: rgba(255,255,255,.025); border: 1px solid var(--border);
      border-radius: 14px; padding: 14px 18px; cursor: pointer; text-align: left;
      transition: border-color .2s, background .2s, transform .15s;
      user-select: none; width: 100%;
    }
    .option-btn:hover:not([disabled]) {
      background: rgba(255,255,255,.045);
      border-color: var(--accent-ring);
      transform: translateX(2px);
    }
    .option-btn.correct { border-color: var(--green) !important; background: var(--green-bg) !important; animation: correctPulse .6s ease; }
    .option-btn.wrong   { border-color: var(--red)   !important; background: var(--red-bg)   !important; animation: wrongShake .4s ease; }
    .option-btn.dimmed  { opacity: .4; cursor: default; }
    .option-btn[disabled] { cursor: default; }

    .option-letter {
      width: 28px; height: 28px; flex-shrink: 0; border-radius: 7px;
      background: rgba(255,255,255,.06); border: 1px solid var(--border);
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 700; color: var(--text3);
      transition: background .2s, border-color .2s, color .2s;
    }
    .option-btn.correct .option-letter { background: rgba(52,211,153,.2); border-color: var(--green); color: var(--green); }
    .option-btn.wrong   .option-letter { background: rgba(248,113,113,.2); border-color: var(--red);   color: var(--red); }
    .option-content { flex: 1; }
    .option-text { font-size: 14px; color: var(--text2); line-height: 1.5; }
    .option-btn.correct .option-text,
    .option-btn.wrong   .option-text { color: var(--text); }

    /* Feedback panel */
    .feedback-panel {
      max-height: 0; overflow: hidden;
      transition: max-height .4s ease;
      border-radius: 12px;
    }
    .feedback-panel.visible { max-height: 700px; }
    .feedback-inner {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 12px; overflow: hidden;
    }
    .feedback-header {
      padding: 14px 20px;
      font-size: 15px; font-weight: 700;
      display: flex; align-items: center; gap: 10px;
    }
    .feedback-header.correct { background: rgba(52,211,153,.08); color: var(--green); border-bottom: 1px solid rgba(52,211,153,.18); }
    .feedback-header.wrong   { background: rgba(248,113,113,.07); color: var(--red);   border-bottom: 1px solid rgba(248,113,113,.18); }
    .feedback-explanation {
      padding: 16px 20px;
      font-size: 13px; color: var(--text2); line-height: 1.65;
      border-bottom: 1px solid var(--border);
    }
    .feedback-distractors { padding: 12px 20px 16px; display: flex; flex-direction: column; gap: 8px; }
    .distractor-row { display: flex; gap: 10px; font-size: 12px; }
    .distractor-letter { color: var(--text3); font-weight: 700; flex-shrink: 0; min-width: 56px; }
    .distractor-text   { color: var(--text3); line-height: 1.5; }
    .feedback-actions {
      display: flex; gap: 10px; padding: 14px 20px;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,.015);
    }

    /* â”€â”€ Shared button styles â”€â”€ */
    .btn-primary {
      flex: 1; padding: 13px 18px;
      background: linear-gradient(135deg, var(--accent-light), var(--accent));
      color: #fff; font-family: inherit; font-size: 14px; font-weight: 700;
      border: none; border-radius: 10px; cursor: pointer;
      box-shadow: 0 4px 16px rgba(99,102,241,.28);
      transition: transform .2s, box-shadow .2s;
    }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99,102,241,.38); }
    .btn-secondary {
      padding: 13px 18px;
      background: rgba(255,255,255,.04); border: 1px solid var(--border);
      color: var(--text2); font-family: inherit; font-size: 14px; font-weight: 600;
      border-radius: 10px; cursor: pointer; transition: border-color .2s, background .2s;
    }
    .btn-secondary:hover { background: rgba(255,255,255,.07); border-color: var(--accent-ring); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN â€” RESULTS  (populated in Chunk 6)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #screen-results.active {
      display: flex; flex-direction: column;
      min-height: calc(100vh - 58px);
      padding: 40px 24px 60px;
    }

    .results-inner {
      max-width: 680px; width: 100%; margin: 0 auto;
      display: flex; flex-direction: column; gap: 28px;
      animation: fadeInUp .5s ease-out both;
    }
    .results-hero { text-align: center; padding: 24px 0 12px; }
    .results-hero h1 {
      font-family: 'Instrument Serif', Georgia, serif;
      font-size: clamp(2rem, 5vw, 3.2rem); line-height: 1.1;
    }
    .results-hero h1 em { font-style: italic; color: var(--accent-light); }

    /* Score ring */
    .results-ring-wrap { margin: 24px auto 0; width: 130px; height: 130px; position: relative; }
    .results-ring-wrap svg { width: 100%; height: 100%; }
    .ring-bg   { fill: none; stroke: rgba(255,255,255,.06); stroke-width: 10; }
    .ring-fill { fill: none; stroke: var(--accent); stroke-width: 10; stroke-linecap: round; }
    .ring-text-overlay {
      position: absolute; inset: 0;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .ring-pct   { font-family: 'Instrument Serif', serif; font-size: 2rem; line-height: 1; }
    .ring-label { font-size: 11px; color: var(--text3); margin-top: 2px; }

    /* Summary stats row */
    .results-summary {
      background: rgba(255,255,255,.025); border: 1px solid var(--accent-ring);
      border-radius: 16px; padding: 20px 24px;
      display: flex; gap: 20px; flex-wrap: wrap; justify-content: space-around;
    }
    .rs-item { display: flex; flex-direction: column; gap: 4px; align-items: center; }
    .rs-label { font-size: 10px; color: var(--text3); text-transform: uppercase; letter-spacing: .08em; }
    .rs-val   { font-family: 'Instrument Serif', serif; font-size: 1.4rem; color: var(--accent-light); }

    /* Type breakdown */
    .type-breakdown { display: flex; flex-direction: column; gap: 10px; }
    .breakdown-title { font-size: 11px; font-weight: 700; letter-spacing: .1em; text-transform: uppercase; color: var(--text3); margin-bottom: 4px; }
    .type-row-item {
      background: rgba(255,255,255,.025); border: 1px solid var(--border);
      border-radius: 12px; padding: 10px 16px;
      display: flex; align-items: center; gap: 14px;
    }
    .type-badge-sm {
      font-size: 10px; font-weight: 700; letter-spacing: .06em;
      padding: 3px 8px; border-radius: 5px; border: 1px solid transparent;
      white-space: nowrap; min-width: 80px; text-align: center;
    }
    .type-bar-track { flex: 1; height: 6px; background: rgba(255,255,255,.07); border-radius: 3px; overflow: hidden; }
    .type-bar-fill  { height: 100%; border-radius: 3px; transition: width .8s .2s ease; width: 0%; }
    .type-fraction  { font-size: 12px; font-weight: 600; color: var(--text2); width: 36px; text-align: right; }

    /* Domain breakdown */
    .domain-breakdown { display: flex; flex-direction: column; gap: 10px; }
    .db-row {
      background: rgba(255,255,255,.025); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px 16px;
      display: flex; align-items: center; gap: 14px;
    }
    .db-domain { font-size: 11px; font-weight: 700; color: var(--accent-light); width: 44px; flex-shrink: 0; }
    .db-track  { flex: 1; height: 6px; background: rgba(255,255,255,.07); border-radius: 3px; overflow: hidden; }
    .db-fill   { height: 100%; border-radius: 3px; background: var(--accent); transition: width .8s .2s ease; width: 0%; }
    .db-fill.high { background: var(--green); }
    .db-fill.mid  { background: #fbbf24; }
    .db-fill.low  { background: var(--red); }
    .db-score  { font-size: 12px; font-weight: 600; color: var(--text2); width: 36px; text-align: right; }

    /* Replay list */
    .replay-section { display: flex; flex-direction: column; gap: 10px; }
    .replay-title { font-size: 11px; font-weight: 700; letter-spacing: .1em; text-transform: uppercase; color: var(--text3); }
    .replay-row {
      display: flex; align-items: center; gap: 12px;
      background: rgba(255,255,255,.025); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px 16px;
    }
    .replay-outcome { font-size: 15px; font-weight: 700; flex-shrink: 0; width: 20px; }
    .replay-outcome.correct { color: var(--green); }
    .replay-outcome.wrong   { color: var(--red); }
    .replay-label  { flex: 1; font-size: 13px; color: var(--text2); }
    .replay-domain { font-size: 10px; font-weight: 700; color: var(--text3); letter-spacing: .06em; flex-shrink: 0; }
    .btn-replay {
      padding: 6px 14px; font-size: 12px; font-weight: 600;
      color: var(--accent-light); background: rgba(99,102,241,.08);
      border: 1px solid var(--accent-ring); border-radius: 7px;
      cursor: pointer; flex-shrink: 0; transition: background .2s;
    }
    .btn-replay:hover { background: var(--accent-glow); }

    /* Results action buttons */
    .results-actions { display: flex; gap: 12px; flex-wrap: wrap; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RESPONSIVE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    @media (max-width: 760px) {
      .encounter-layout {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }
      .patient-stage { border-right: none; border-bottom: 1px solid var(--border); }
      .chart-panel   { border-left: none; border-top: 1px solid var(--border); max-height: 260px; }
      .phase-controls { grid-column: 1; }
      .avatar-wrap { width: 150px; height: 240px; }
      #screen-question.active { padding: 20px 16px 60px; }
      #screen-results.active  { padding: 24px 16px 60px; }
    }
  </style>
</head>
<body>

  <div class="blob blob-a"></div>
  <div class="blob blob-b"></div>

  <!-- â”€â”€ Nav â”€â”€ -->
  <nav>
    <a href="clinical-presentation-settings.html" class="back-btn" id="nav-back">â† Settings</a>
    <div class="nav-sep"></div>
    <a href="index.html" class="nav-logo">
      <div class="logo-icon">M</div>
      <span class="logo-title">MasteryPage</span>
    </a>
    <div class="nav-right">
      <span class="nav-progress" id="nav-progress"></span>
    </div>
  </nav>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN: LOADING
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="screen-loading" class="screen active">
    <div class="loader-card">
      <div class="loader-module-icon">âš•</div>
      <div class="loader-spinner"></div>
      <div class="loader-status" id="loader-status">Loading encountersâ€¦</div>
      <div class="loader-bar-track">
        <div class="loader-bar-fill" id="loader-fill"></div>
      </div>
      <div class="loader-detail" id="loader-detail">Preparing patient cases</div>
      <a href="clinical-presentation-settings.html" class="loader-back" id="loader-back">â† Back to Settings</a>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN: ENCOUNTER  (shell â€” Chunks 3 & 4 populate this)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="screen-encounter" class="screen">
    <div class="encounter-layout">

      <!-- Left: patient stage -->
      <div class="patient-stage" id="patient-stage">

        <!-- Speech bubble (above avatar) -->
        <div class="speech-bubble hidden" id="speech-bubble">
          <div class="bubble-tail"></div>
          <div class="clinician-probe" id="clinician-probe"></div>
          <div class="bubble-dots" id="bubble-dots">
            <span></span><span></span><span></span>
          </div>
          <div class="bubble-text" id="bubble-text"></div>
        </div>

        <!-- Avatar container â€” inline SVG patient -->
        <div class="avatar-wrap" id="avatar-wrap">
          <svg id="avatar-root" class="state-idle"
               viewBox="0 0 200 320" xmlns="http://www.w3.org/2000/svg"
               style="width:100%;height:100%;overflow:visible">
            <defs>
              <!-- Skin gradient â€” body -->
              <linearGradient id="g-skin" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%"   stop-color="#f5c9a0"/>
                <stop offset="100%" stop-color="#e8a87c"/>
              </linearGradient>
              <!-- Skin gradient â€” face (slightly lighter) -->
              <linearGradient id="g-skin-face" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%"   stop-color="#f8d4ae"/>
                <stop offset="100%" stop-color="#efb98a"/>
              </linearGradient>
              <!-- Clothing gradient -->
              <linearGradient id="g-cloth" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%"   stop-color="#5b6fa6"/>
                <stop offset="100%" stop-color="#3b4f7e"/>
              </linearGradient>
              <!-- Chair gradient -->
              <linearGradient id="g-chair" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%"   stop-color="#4a4a5a"/>
                <stop offset="100%" stop-color="#2e2e3a"/>
              </linearGradient>
              <!-- Drop shadow for body group -->
              <filter id="f-avatar-shadow" x="-20%" y="-10%" width="140%" height="130%">
                <feDropShadow dx="0" dy="4" stdDeviation="5" flood-color="rgba(0,0,0,0.35)"/>
              </filter>
              <!-- Subtle inner shadow / glow filter -->
              <filter id="f-subtle" x="-5%" y="-5%" width="110%" height="110%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
                <feComposite in="SourceGraphic" in2="blur" operator="over"/>
              </filter>
            </defs>

            <!-- â”€â”€ CHAIR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
            <g id="chair">
              <!-- Back rest -->
              <rect x="60" y="170" width="80" height="110" rx="6"
                    fill="url(#g-chair)" stroke="#222" stroke-width="1.2"/>
              <!-- Seat -->
              <rect x="52" y="255" width="96" height="18" rx="5"
                    fill="#3a3a4a" stroke="#222" stroke-width="1"/>
              <!-- Left armrest -->
              <rect x="46" y="230" width="16" height="44" rx="4"
                    fill="#3a3a4a" stroke="#222" stroke-width="1"/>
              <!-- Right armrest -->
              <rect x="138" y="230" width="16" height="44" rx="4"
                    fill="#3a3a4a" stroke="#222" stroke-width="1"/>
              <!-- Left front leg -->
              <rect x="56" y="273" width="8" height="36" rx="3" fill="#2a2a38"/>
              <!-- Right front leg -->
              <rect x="136" y="273" width="8" height="36" rx="3" fill="#2a2a38"/>
              <!-- Left rear leg -->
              <rect x="66" y="278" width="6" height="30" rx="2" fill="#252530"/>
              <!-- Right rear leg -->
              <rect x="128" y="278" width="6" height="30" rx="2" fill="#252530"/>
              <!-- Cross brace -->
              <rect x="56" y="292" width="88" height="5" rx="2" fill="#2a2a38"/>
              <!-- Floor shadow -->
              <ellipse cx="100" cy="312" rx="44" ry="5"
                       fill="rgba(0,0,0,0.25)"/>
            </g>

            <!-- â”€â”€ BODY GROUP (breathing pivot: 100,185) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
            <g id="avatar-body"
               style="transform-origin:100px 185px"
               filter="url(#f-avatar-shadow)">

              <!-- Legs -->
              <g id="avatar-legs">
                <!-- Left thigh -->
                <rect x="74" y="220" width="22" height="50" rx="8"
                      fill="url(#g-cloth)"/>
                <!-- Right thigh -->
                <rect x="104" y="220" width="22" height="50" rx="8"
                      fill="url(#g-cloth)"/>
                <!-- Left lower leg -->
                <rect x="76" y="262" width="18" height="32" rx="6"
                      fill="#374a7a"/>
                <!-- Right lower leg -->
                <rect x="106" y="262" width="18" height="32" rx="6"
                      fill="#374a7a"/>
                <!-- Left shoe -->
                <ellipse cx="85" cy="295" rx="13" ry="7" fill="#282828"/>
                <ellipse cx="81" cy="293" rx="5"  ry="3" fill="rgba(255,255,255,0.08)"/>
                <!-- Right shoe -->
                <ellipse cx="115" cy="295" rx="13" ry="7" fill="#282828"/>
                <ellipse cx="111" cy="293" rx="5"  ry="3" fill="rgba(255,255,255,0.08)"/>
              </g>

              <!-- Torso -->
              <path d="M72 185 Q68 205 70 230 L130 230 Q132 205 128 185 Q114 175 100 175 Q86 175 72 185Z"
                    fill="url(#g-cloth)"/>
              <!-- Collar / neckline V detail -->
              <path d="M93 183 L100 196 L107 183"
                    fill="none" stroke="rgba(255,255,255,0.18)" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round"/>
              <!-- Center crease -->
              <line x1="100" y1="196" x2="100" y2="226"
                    stroke="rgba(0,0,0,0.15)" stroke-width="1"/>

              <!-- Arms -->
              <g id="avatar-arms">
                <!-- Left upper arm -->
                <path d="M73 188 Q60 198 62 218 Q68 224 74 218 Q72 202 80 194Z"
                      fill="url(#g-cloth)"/>
                <!-- Right upper arm -->
                <path d="M127 188 Q140 198 138 218 Q132 224 126 218 Q128 202 120 194Z"
                      fill="url(#g-cloth)"/>
                <!-- Left forearm -->
                <path d="M62 218 Q58 234 62 248 Q68 252 72 246 Q68 232 74 218Z"
                      fill="url(#g-skin)"/>
                <!-- Right forearm -->
                <path d="M138 218 Q142 234 138 248 Q132 252 128 246 Q132 232 126 218Z"
                      fill="url(#g-skin)"/>

                <!-- Hands (folded in lap, pivot: 100,214) -->
                <g id="avatar-hand" style="transform-origin:100px 214px">
                  <!-- Left hand -->
                  <path d="M76 248 Q72 256 76 264 Q84 268 92 264 Q96 258 94 250 Q86 246 76 248Z"
                        fill="url(#g-skin)"/>
                  <!-- Right hand -->
                  <path d="M124 248 Q128 256 124 264 Q116 268 108 264 Q104 258 106 250 Q114 246 124 248Z"
                        fill="url(#g-skin)"/>
                  <!-- Folded knuckle ellipse (center overlap) -->
                  <ellipse cx="100" cy="258" rx="10" ry="6"
                           fill="url(#g-skin)" stroke="#dba070" stroke-width="0.5"/>
                  <!-- Finger crease lines -->
                  <line x1="83"  y1="256" x2="82"  y2="263" stroke="#dba070" stroke-width="0.8" stroke-linecap="round"/>
                  <line x1="88"  y1="254" x2="87"  y2="262" stroke="#dba070" stroke-width="0.8" stroke-linecap="round"/>
                  <line x1="112" y1="256" x2="113" y2="263" stroke="#dba070" stroke-width="0.8" stroke-linecap="round"/>
                  <line x1="117" y1="254" x2="118" y2="262" stroke="#dba070" stroke-width="0.8" stroke-linecap="round"/>
                </g>
              </g>

              <!-- â”€â”€ HEAD GROUP (tilt pivot: 100,130) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
              <g id="avatar-head" style="transform-origin:100px 130px">

                <!-- Hair â€” back mass behind head -->
                <g id="avatar-hair">
                  <ellipse cx="100" cy="100" rx="34" ry="38"
                           fill="#3a2010"/>
                  <!-- Left side wisp -->
                  <path d="M68 100 Q62 115 66 128" fill="none"
                        stroke="#3a2010" stroke-width="8" stroke-linecap="round"/>
                  <!-- Right side wisp -->
                  <path d="M132 100 Q138 115 134 128" fill="none"
                        stroke="#3a2010" stroke-width="8" stroke-linecap="round"/>
                </g>

                <!-- Neck -->
                <rect x="91" y="134" width="18" height="22" rx="4"
                      fill="url(#g-skin)"/>
                <!-- Neck shadow -->
                <line x1="91" y1="140" x2="109" y2="140"
                      stroke="rgba(0,0,0,0.1)" stroke-width="2"/>

                <!-- Head ellipse -->
                <ellipse id="avatar-head-shape" cx="100" cy="107" rx="29" ry="34"
                         fill="url(#g-skin-face)"/>

                <!-- Left ear -->
                <ellipse cx="71" cy="110" rx="5" ry="7" fill="url(#g-skin)"/>
                <ellipse cx="71" cy="110" rx="2.5" ry="4" fill="#e8a87c"/>
                <!-- Right ear -->
                <ellipse cx="129" cy="110" rx="5" ry="7" fill="url(#g-skin)"/>
                <ellipse cx="129" cy="110" rx="2.5" ry="4" fill="#e8a87c"/>

                <!-- Face elements -->
                <g id="avatar-face">

                  <!-- Brows -->
                  <g id="avatar-brow">
                    <path d="M82 93 Q88 90 94 92" fill="none"
                          stroke="#5a3010" stroke-width="2.2" stroke-linecap="round"/>
                    <path d="M106 92 Q112 90 118 93" fill="none"
                          stroke="#5a3010" stroke-width="2.2" stroke-linecap="round"/>
                  </g>

                  <!-- Eyes -->
                  <g id="avatar-eyes">
                    <!-- Socket shadows -->
                    <ellipse cx="88"  cy="107" rx="8" ry="7" fill="rgba(0,0,0,0.06)"/>
                    <ellipse cx="112" cy="107" rx="8" ry="7" fill="rgba(0,0,0,0.06)"/>
                    <!-- Eye whites -->
                    <ellipse cx="88"  cy="107" rx="7"   ry="5.5" fill="#fff"/>
                    <ellipse cx="112" cy="107" rx="7"   ry="5.5" fill="#fff"/>
                    <!-- Irises -->
                    <circle  cx="88"  cy="107" r="3.8" fill="#5a7ab5"/>
                    <circle  cx="112" cy="107" r="3.8" fill="#5a7ab5"/>
                    <!-- Pupils -->
                    <circle  cx="88"  cy="107" r="2"   fill="#1a1a28"/>
                    <circle  cx="112" cy="107" r="2"   fill="#1a1a28"/>
                    <!-- Highlights -->
                    <circle  cx="89.5" cy="105.5" r="1" fill="rgba(255,255,255,0.75)"/>
                    <circle  cx="113.5" cy="105.5" r="1" fill="rgba(255,255,255,0.75)"/>
                    <!-- Lid lines -->
                    <path d="M81 104 Q88 101 95 104" fill="none"
                          stroke="#c08060" stroke-width="0.8" stroke-linecap="round"/>
                    <path d="M105 104 Q112 101 119 104" fill="none"
                          stroke="#c08060" stroke-width="0.8" stroke-linecap="round"/>
                  </g>

                  <!-- Nose -->
                  <g id="avatar-nose">
                    <path d="M100 110 Q97 116 96 118 Q100 121 104 118 Q103 116 100 110Z"
                          fill="none" stroke="#c08060" stroke-width="1"
                          stroke-linecap="round" stroke-linejoin="round"/>
                    <ellipse cx="96.5" cy="118.5" rx="2.5" ry="1.5" fill="rgba(0,0,0,0.1)"/>
                    <ellipse cx="103.5" cy="118.5" rx="2.5" ry="1.5" fill="rgba(0,0,0,0.1)"/>
                  </g>

                  <!-- Jaw / lower face (speak pivot: 100,126) -->
                  <g id="avatar-jaw" style="transform-origin:100px 126px">
                    <!-- Lower jaw path -->
                    <path d="M75 120 Q78 136 100 142 Q122 136 125 120"
                          fill="url(#g-skin-face)" stroke="none"/>
                    <!-- Chin highlight -->
                    <ellipse cx="100" cy="139" rx="6" ry="2.5"
                             fill="rgba(255,255,255,0.12)"/>
                    <!-- Mouth -->
                    <path id="avatar-mouth" d="M91 126 Q100 131 109 126"
                          fill="none" stroke="#b07050" stroke-width="1.8"
                          stroke-linecap="round"/>
                    <!-- Philtrum -->
                    <path d="M98 122 Q100 124 102 122"
                          fill="none" stroke="#c08860" stroke-width="0.9"
                          stroke-linecap="round"/>
                  </g>

                  <!-- Tears (hidden by default; tearFall animates group opacity 0â†’0.85â†’0) -->
                  <g id="avatar-tear" opacity="0">
                    <ellipse class="tear-left"  cx="85"  cy="114" rx="2" ry="3"
                             fill="rgba(180,210,255,0.85)"/>
                    <ellipse class="tear-right" cx="115" cy="114" rx="2" ry="3"
                             fill="rgba(180,210,255,0.85)"/>
                  </g>

                </g><!-- /avatar-face -->
              </g><!-- /avatar-head -->
            </g><!-- /avatar-body -->
          </svg>
        </div>

        <!-- Patient info bar (below avatar) -->
        <div class="patient-info-bar" id="patient-info-bar">
          <span class="patient-label" id="patient-label">â€”</span>
          <div class="patient-info-sep"></div>
          <span class="patient-setting" id="patient-setting">â€”</span>
        </div>

        <!-- Behavioral tag overlay -->
        <div class="tag-overlay" id="tag-overlay"></div>

      </div>

      <!-- Right: clinical chart -->
      <div class="chart-panel" id="chart-panel">
        <div class="chart-header">
          <span>ğŸ“‹</span>
          <span class="chart-title">Clinical Chart</span>
        </div>
        <div class="chart-body" id="chart-body"></div>
      </div>

      <!-- Bottom: phase controls -->
      <div class="phase-controls" id="phase-controls">
        <div class="phase-indicator">
          <span class="phase-num" id="phase-label">â€”</span>
          <div class="phase-dots" id="phase-dots"></div>
        </div>
        <button class="btn-advance hidden" id="btn-advance" onclick="advancePhase()">
          Next <span>â†’</span>
        </button>
        <div class="auto-bar" id="auto-bar">
          <div class="auto-bar-fill" id="auto-bar-fill"></div>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN: QUESTION  (shell â€” Chunk 5 populates this)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="screen-question" class="screen">
    <div class="question-wrap" id="question-wrap">

      <div class="q-header">
        <span class="q-type-badge" id="q-type-badge"></span>
        <span class="q-multi-indicator" id="q-multi"></span>
        <span class="q-encounter-counter" id="q-counter"></span>
      </div>

      <div class="q-prompt" id="q-prompt"></div>

      <div class="options-grid" id="options-grid"></div>

      <div class="feedback-panel" id="feedback-panel">
        <div class="feedback-inner">
          <div class="feedback-header" id="feedback-header"></div>
          <div class="feedback-explanation" id="feedback-explanation"></div>
          <div class="feedback-distractors" id="feedback-distractors"></div>
          <div class="feedback-actions">
            <button class="btn-secondary" id="btn-review-enc" onclick="reviewEncounter()">Review Case</button>
            <button class="btn-primary"   id="btn-next-q"     onclick="nextQuestion()">Next â†’</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SCREEN: RESULTS  (shell â€” Chunk 6 populates this)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="screen-results" class="screen">
    <div class="results-inner">

      <div class="results-hero">
        <div class="results-ring-wrap">
          <svg viewBox="0 0 130 130">
            <circle class="ring-bg" cx="65" cy="65" r="52"
              transform="rotate(-90 65 65)"/>
            <circle class="ring-fill" id="ring-fill" cx="65" cy="65" r="52"
              stroke-dasharray="326.7" stroke-dashoffset="326.7"
              transform="rotate(-90 65 65)"/>
          </svg>
          <div class="ring-text-overlay">
            <span class="ring-pct" id="ring-pct">â€”</span>
            <span class="ring-label">score</span>
          </div>
        </div>
        <h1 id="results-heading" style="margin-top:20px;">Session <em>Complete</em></h1>
      </div>

      <div class="results-summary" id="results-summary"></div>

      <div class="type-breakdown">
        <div class="breakdown-title">By Question Type</div>
        <div id="type-rows"></div>
      </div>

      <div class="domain-breakdown">
        <div class="breakdown-title">By Domain</div>
        <div id="domain-rows"></div>
      </div>

      <div class="replay-section">
        <div class="replay-title">Case Review</div>
        <div id="replay-list"></div>
      </div>

      <div class="results-actions">
        <button class="btn-primary"   onclick="newSession()">New Session</button>
        <button class="btn-secondary" onclick="retrySession()">Try Again</button>
      </div>

    </div>
  </div>

  <script>
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CONSTANTS
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  const ALL_DOMAINS  = ['PMET','LDEV','CPAT','PTHE','SOCU','WDEV','BPSY','CASS','PETH'];

  const LEVEL_LABELS = { 1:'Foundational', 2:'Intermediate', 3:'Advanced', 4:'Expert' };

  const SPEED_CONFIG = {
    slow:   { charMs: 50, holdMs: 3000 },
    normal: { charMs: 30, holdMs: 1500 },
    fast:   { charMs: 12, holdMs: 500  },
    manual: { charMs: 30, holdMs: 0    },
  };

  const TYPE_BADGE = {
    primary_diagnosis:     { label: 'Diagnosis',    color: '#6366f1' },
    differential_diagnosis:{ label: 'Differential', color: '#60a5fa' },
    immediate_intervention:{ label: 'Urgent Care',  color: '#f87171' },
    treatment_planning:    { label: 'Treatment',    color: '#34d399' },
    risk_assessment:       { label: 'Risk',         color: '#fb923c' },
    dsm_criteria:          { label: 'DSM-5-TR',     color: '#a78bfa' },
    cultural_consideration:{ label: 'Cultural',     color: '#2dd4bf' },
    assessment_tool:       { label: 'Assessment',   color: '#d4a054' },
  };

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CONFIG â€” parsed from URLSearchParams
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  const sp = new URLSearchParams(location.search);

  const CFG = {
    domains:   sp.get('domains') === 'mixed'
                 ? ALL_DOMAINS
                 : (sp.get('domains') || ALL_DOMAINS.join(',')).split(',').filter(Boolean),
    levels:    (sp.get('levels') || '1,2,3,4').split(',').map(Number),
    count:     parseInt(sp.get('count'))  || 10,
    order:     sp.get('order')  || 'shuffled',
    speed:     sp.get('speed')  || 'normal',
    showTags:  sp.get('tags')   !== '0',
    showChart: sp.get('chart')  !== '0',
  };

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SESSION STATE
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  const state = {
    pool:           [],   // EncounterObject[] after filter + sort + slice
    encIdx:         0,    // current encounter index
    phaseIdx:       0,    // current phase index within encounter
    qIdx:           0,    // current question index within encounter
    answered:       false,
    phaseRunning:   false,
    typewriterInt:  null,
    autoAdvanceInt: null,
    avatarState:    'idle',
    domainScores:   {},   // { CODE: { correct, total } }
    typeScores:     {},   // { type: { correct, total } }
    sessionAnswers: [],   // [ { encId, qId, type, correct, domain } ]
    reviewMode:     false,
  };

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SCREEN MANAGER
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function showScreen(name) {
    // Clear running intervals
    clearInterval(state.typewriterInt);
    clearInterval(state.autoAdvanceInt);

    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById('screen-' + name).classList.add('active');

    // Update nav back target based on screen
    const backBtn = document.getElementById('nav-back');
    if (name === 'encounter' || name === 'question') {
      backBtn.href = 'clinical-presentation-settings.html';
    }

    // Show/hide nav progress counter
    const navProg = document.getElementById('nav-progress');
    if (name === 'encounter' || name === 'question') {
      navProg.textContent = `Encounter ${state.encIdx + 1} of ${state.pool.length}`;
      navProg.classList.add('visible');
    } else {
      navProg.classList.remove('visible');
    }
  }

  function showError(msg) {
    const status = document.getElementById('loader-status');
    const detail = document.getElementById('loader-detail');
    const back   = document.getElementById('loader-back');
    const spinner = document.querySelector('.loader-spinner');
    status.textContent = msg;
    status.classList.add('error');
    detail.textContent = '';
    if (spinner) spinner.style.display = 'none';
    back.classList.add('visible');
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     HELPERS
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function escapeHtml(s) {
    if (!s) return '';
    return String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  function getStoredScores() {
    try { return JSON.parse(localStorage.getItem('encounter_scores') || '{}'); }
    catch { return {}; }
  }

  function getStoredTypeScores() {
    try { return JSON.parse(localStorage.getItem('encounter_type_scores') || '{}'); }
    catch { return {}; }
  }

  function persistScores() {
    // Accumulate domain scores into localStorage
    const allDomain = getStoredScores();
    Object.entries(state.domainScores).forEach(([d, s]) => {
      allDomain[d] = allDomain[d] || { correct: 0, total: 0 };
      allDomain[d].correct += s.correct;
      allDomain[d].total   += s.total;
    });
    localStorage.setItem('encounter_scores', JSON.stringify(allDomain));

    const allType = getStoredTypeScores();
    Object.entries(state.typeScores).forEach(([t, s]) => {
      allType[t] = allType[t] || { correct: 0, total: 0 };
      allType[t].correct += s.correct;
      allType[t].total   += s.total;
    });
    localStorage.setItem('encounter_type_scores', JSON.stringify(allType));
  }

  function initDomainScores() {
    for (const enc of state.pool) {
      const d = enc.domain_code;
      if (!state.domainScores[d]) state.domainScores[d] = { correct: 0, total: 0 };
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     POOL SORTING
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function sortPool(pool) {
    if (CFG.order === 'weakest') {
      const stored = getStoredScores();
      const byDomain = {};
      pool.forEach(e => {
        if (!byDomain[e.domain_code]) byDomain[e.domain_code] = [];
        byDomain[e.domain_code].push(e);
      });
      const domainOrder = Object.keys(byDomain).sort((a, b) => {
        const aS = stored[a], bS = stored[b];
        const aA = aS && aS.total ? aS.correct / aS.total : 0.5;
        const bA = bS && bS.total ? bS.correct / bS.total : 0.5;
        return aA - bA;
      });
      return domainOrder.flatMap(d => shuffle(byDomain[d]));
    }
    if (CFG.order === 'sequential') {
      return pool.slice().sort((a, b) =>
        (a.domain_code + a.subdomain).localeCompare(b.domain_code + b.subdomain)
      );
    }
    return shuffle(pool.slice());
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     DATA LOADING
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  async function loadEncounters() {
    const fillEl  = document.getElementById('loader-fill');
    const statusEl = document.getElementById('loader-status');
    const detailEl = document.getElementById('loader-detail');

    let pool = [];

    for (let i = 0; i < CFG.domains.length; i++) {
      const d = CFG.domains[i];
      statusEl.textContent = `Loading ${d}â€¦`;
      detailEl.textContent = `${i + 1} of ${CFG.domains.length} domains`;
      fillEl.style.width = ((i / CFG.domains.length) * 85) + '%';

      try {
        const r = await fetch(`data/${d}_presentations.json`);
        if (!r.ok) {
          console.warn(`[loader] ${d}: HTTP ${r.status} â€” skipping`);
          continue;
        }
        const data = await r.json();
        const allEnc = data.encounters || [];
        const filtered = allEnc.filter(e => CFG.levels.includes(e.difficulty_level));
        pool.push(...filtered);
        console.log(`[loader] ${d}: ${filtered.length}/${allEnc.length} encounters matched`);
      } catch (err) {
        console.warn(`[loader] ${d}: fetch failed â€”`, err.message);
      }
    }

    fillEl.style.width = '90%';
    statusEl.textContent = 'Building sessionâ€¦';
    detailEl.textContent = `${pool.length} encounter${pool.length !== 1 ? 's' : ''} available`;

    if (pool.length === 0) {
      showError('No encounters match your settings. Go back and adjust your filters.');
      return;
    }

    // Sort and slice
    pool = sortPool(pool);
    state.pool = pool.slice(0, CFG.count);
    initDomainScores();

    // Log summary for verification
    const dist = {};
    state.pool.forEach(e => { dist[e.domain_code] = (dist[e.domain_code] || 0) + 1; });
    console.log(`[loader] Pool ready: ${state.pool.length} encounters`, dist);
    console.log(`[loader] CFG:`, CFG);

    fillEl.style.width = '100%';
    detailEl.textContent = `${state.pool.length} encounters ready`;

    await new Promise(r => setTimeout(r, 380));

    // Transition to encounter screen
    state.encIdx   = 0;
    state.phaseIdx = 0;
    state.qIdx     = 0;
    showScreen('encounter');
    startEncounter(state.pool[0]);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ENCOUNTER ENGINE  (Chunks 3 & 4 fill in the animation bodies)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

  function startEncounter(enc) {
    // Patient info bar
    document.getElementById('patient-label').textContent   = enc.encounter.patient.label || 'â€”';
    document.getElementById('patient-setting').textContent = enc.encounter.setting || 'â€”';

    // Clear chart, build section containers
    buildChartSections(enc);

    // Clear behavioral tags and reset slot index
    document.getElementById('tag-overlay').innerHTML = '';
    _tagSlotIdx = 0;
    cancelTagStagger();

    // Build phase dots
    buildPhaseDots(enc.encounter.phases.length);

    // Set initial avatar state
    setAvatarState(enc.encounter.patient.initial_avatar_state || 'idle');

    // Hide speech bubble until first phase
    const bubble = document.getElementById('speech-bubble');
    bubble.classList.add('hidden');
    document.getElementById('bubble-text').textContent = '';
    document.getElementById('clinician-probe').classList.remove('visible');

    // Reset state
    state.phaseIdx = 0;
    state.phaseRunning = false;
    state.reviewMode = false;

    // Update nav progress
    document.getElementById('nav-progress').textContent =
      `Encounter ${state.encIdx + 1} of ${state.pool.length}`;
    document.getElementById('nav-progress').classList.add('visible');

    // Start first phase
    startPhase(enc.encounter.phases[0]);
  }

  function buildChartSections(enc) {
    const body = document.getElementById('chart-body');
    body.innerHTML = '';

    // Collect all categories that appear in this encounter
    const cats = new Set();
    enc.encounter.phases.forEach(ph =>
      (ph.chart_reveals || []).forEach(r => cats.add(r.category))
    );

    // Render one empty section div per category (in canonical order)
    const CATEGORY_ORDER = [
      'Chief Complaint',
      'History of Present Illness',
      'Mental Status Examination',
      'Psychosocial History',
      'Collateral / Context',
      'Labs / Observations',
    ];
    CATEGORY_ORDER.forEach(cat => {
      if (!cats.has(cat)) return;
      const sec = document.createElement('div');
      sec.className = 'chart-section';
      sec.id = 'chart-sec-' + cat.replace(/[^a-zA-Z0-9]/g, '-');
      sec.innerHTML = `<div class="chart-section-label">${escapeHtml(cat)}</div>`;
      body.appendChild(sec);
    });
  }

  function buildPhaseDots(count) {
    const container = document.getElementById('phase-dots');
    container.innerHTML = '';
    for (let i = 0; i < count; i++) {
      const dot = document.createElement('div');
      dot.className = 'phase-dot' + (i === 0 ? ' current' : '');
      dot.id = `phase-dot-${i}`;
      container.appendChild(dot);
    }
  }

  function updatePhaseDots(currentIdx) {
    const enc = state.pool[state.encIdx];
    enc.encounter.phases.forEach((_, i) => {
      const dot = document.getElementById(`phase-dot-${i}`);
      if (!dot) return;
      dot.className = 'phase-dot' +
        (i < currentIdx ? ' done' : i === currentIdx ? ' current' : '');
    });
  }

  function startPhase(phase) {
    state.phaseRunning = true;

    // Update phase label and dots
    document.getElementById('phase-label').textContent = phase.phase_label || phase.phase_id;
    updatePhaseDots(state.phaseIdx);

    // Avatar emotion
    setAvatarState(phase.avatar_emotion || 'idle');

    // Cancel any pending tag stagger from previous phase
    cancelTagStagger();

    // Hide advance button during typewriter (shown after in manual mode)
    document.getElementById('btn-advance').classList.add('hidden');

    // Stop any existing auto-advance bar
    stopAutoAdvance();

    // Animate speech bubble in
    const bubble = document.getElementById('speech-bubble');
    bubble.classList.remove('hidden');
    bubble.style.animation = 'none';
    bubble.offsetHeight; // reflow
    bubble.style.animation = '';

    const probe   = document.getElementById('clinician-probe');
    const dots    = document.getElementById('bubble-dots');
    const bubText = document.getElementById('bubble-text');

    bubText.textContent = '';
    dots.classList.remove('hidden');
    probe.classList.remove('visible');
    probe.textContent = '';

    const startTypewriter = () => {
      dots.classList.add('hidden');
      const spd = SPEED_CONFIG[CFG.speed] || SPEED_CONFIG.normal;
      runTypewriter(phase.dialogue || '', spd.charMs, () => {
        // Reveal chart items and behavioral tags with stagger
        revealChartItems(phase.chart_reveals || []);
        revealBehavioralTags(phase.behavioral_tags || []);

        // Wait for all staggered reveals to finish before enabling advance
        const chartMs = (phase.chart_reveals  || []).length * 90;
        const tagMs   = (phase.behavioral_tags || []).length * 150;
        const revealMs = Math.max(chartMs, tagMs, 0);

        setTimeout(() => {
          state.phaseRunning = false;
          if (CFG.speed === 'manual') {
            document.getElementById('btn-advance').classList.remove('hidden');
          } else {
            startAutoAdvance(spd.holdMs);
          }
        }, revealMs);
      });
    };

    if (phase.clinician_prompt) {
      probe.textContent = `Clinician: "${phase.clinician_prompt}"`;
      probe.classList.add('visible');
      setTimeout(() => {
        dots.classList.remove('hidden');
        setTimeout(startTypewriter, 600);
      }, 800);
    } else {
      setTimeout(startTypewriter, 600);
    }
  }

  function runTypewriter(text, charMs, onComplete) {
    clearInterval(state.typewriterInt);
    const el = document.getElementById('bubble-text');
    el.textContent = '';
    let i = 0;
    state.typewriterInt = setInterval(() => {
      el.textContent += text[i++];
      if (i >= text.length) {
        clearInterval(state.typewriterInt);
        state.typewriterInt = null;
        if (onComplete) onComplete();
      }
    }, charMs);
  }

  function revealChartItems(reveals) {
    if (!CFG.showChart || !reveals.length) return;
    reveals.forEach((item, idx) => {
      setTimeout(() => {
        const secId = 'chart-sec-' + item.category.replace(/[^a-zA-Z0-9]/g, '-');
        const sec = document.getElementById(secId);
        if (!sec) return;
        const row = document.createElement('div');
        row.className = 'chart-row';
        row.style.animationDelay = '0ms';
        row.innerHTML = `<span class="chart-key">${escapeHtml(item.label)}</span><span class="chart-val">${escapeHtml(item.value)}</span>`;
        sec.appendChild(row);
        // Scroll chart body to show new item
        const chartBody = document.getElementById('chart-body');
        chartBody.scrollTop = chartBody.scrollHeight;
      }, idx * 90);
    });
  }

  // Tag positioning â€” 8 preset positions distributed around the stage
  const TAG_POSITIONS = [
    { top: '12%',  left: '4%'  },
    { top: '12%',  right: '4%' },
    { top: '30%',  left: '2%'  },
    { top: '30%',  right: '2%' },
    { top: '52%',  left: '4%'  },
    { top: '52%',  right: '4%' },
    { top: '68%',  left: '6%'  },
    { top: '68%',  right: '6%' },
  ];
  let _tagSlotIdx   = 0;
  let _tagTimeouts  = [];

  function cancelTagStagger() {
    _tagTimeouts.forEach(t => clearTimeout(t));
    _tagTimeouts = [];
  }

  function revealBehavioralTags(tags) {
    if (!CFG.showTags || !tags.length) return;
    const overlay = document.getElementById('tag-overlay');

    // Fade existing tags to 50% if stage is already full
    const existing = overlay.querySelectorAll('.behavior-tag');
    if (existing.length >= 8) {
      existing.forEach(t => { t.style.opacity = '0.45'; });
    }

    tags.forEach((tag, idx) => {
      const tid = setTimeout(() => {
        const el = document.createElement('span');
        el.className = 'behavior-tag ' + getTagColor(tag);
        el.textContent = tag;
        el.style.animationDelay = '0ms';

        const pos = TAG_POSITIONS[_tagSlotIdx % TAG_POSITIONS.length];
        _tagSlotIdx++;
        Object.assign(el.style, pos);

        overlay.appendChild(el);
      }, idx * 150);
      _tagTimeouts.push(tid);
    });
  }

  function getTagColor(tag) {
    const t = tag.toLowerCase();
    const redTerms = ['si','hi','self-harm','suicid','homicid','agitat','substance','intoxic','withdrawal'];
    const purpleTerms = ['hallucin','delus','thought disorder','paranoi','dereali','depersonal','dissoci'];
    const orangeTerms = ['anhedonia','flat affect','psychomotor','grandiosi','flight of ideas','pressured','poverty'];
    if (redTerms.some(k => t.includes(k)))    return 'tag-red';
    if (purpleTerms.some(k => t.includes(k))) return 'tag-purple';
    if (orangeTerms.some(k => t.includes(k))) return 'tag-orange';
    return 'tag-blue';
  }

  function startAutoAdvance(holdMs) {
    const bar  = document.getElementById('auto-bar');
    const fill = document.getElementById('auto-bar-fill');
    bar.classList.add('running');
    fill.style.transition = 'none';
    fill.style.width = '0%';
    fill.offsetHeight; // reflow
    fill.style.transition = `width ${holdMs}ms linear`;
    fill.style.width = '100%';

    state.autoAdvanceInt = setTimeout(() => {
      bar.classList.remove('running');
      fill.style.width = '0%';
      advancePhase();
    }, holdMs);
  }

  function stopAutoAdvance() {
    clearTimeout(state.autoAdvanceInt);
    state.autoAdvanceInt = null;
    const bar  = document.getElementById('auto-bar');
    const fill = document.getElementById('auto-bar-fill');
    bar.classList.remove('running');
    fill.style.transition = 'none';
    fill.style.width = '0%';
  }

  function advancePhase() {
    if (state.phaseRunning) return;
    stopAutoAdvance();
    document.getElementById('btn-advance').classList.add('hidden');

    state.phaseIdx++;
    const enc = state.pool[state.encIdx];
    if (state.phaseIdx >= enc.encounter.phases.length) {
      transitionToQuestion();
    } else {
      startPhase(enc.encounter.phases[state.phaseIdx]);
    }
  }

  function transitionToQuestion() {
    const encScreen = document.getElementById('screen-encounter');
    encScreen.classList.add('fading-out');
    setTimeout(() => {
      encScreen.classList.remove('fading-out');
      showScreen('question');
      state.qIdx = 0;
      renderQuestion(state.pool[state.encIdx].questions[0]);
    }, 380);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     AVATAR STATE  (SVG wired in Chunk 3)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function setAvatarState(emotion) {
    const root = document.getElementById('avatar-root');
    if (!root) return;
    root.className = root.className.replace(/\bstate-\S+/g, '').trim();
    root.classList.add('state-' + emotion);
    state.avatarState = emotion;

    // Restart tearFall animation on group when switching to tearful
    if (emotion === 'tearful') {
      const tearGroup = document.getElementById('avatar-tear');
      if (tearGroup) {
        tearGroup.style.animation = 'none';
        tearGroup.offsetHeight; // force reflow
        tearGroup.style.animation = '';
      }
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     QUESTION ENGINE  (Chunk 5 adds full rendering)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function renderQuestion(q) {
    const enc = state.pool[state.encIdx];

    // Type badge
    const badgeConf = TYPE_BADGE[q.type] || { label: q.type, color: '#6366f1' };
    const badge = document.getElementById('q-type-badge');
    badge.textContent = badgeConf.label;
    badge.style.background = badgeConf.color + '1a';
    badge.style.color = badgeConf.color;
    badge.style.borderColor = badgeConf.color + '44';

    // Encounter counter
    document.getElementById('q-counter').textContent =
      `Encounter ${state.encIdx + 1} / ${state.pool.length}`;

    // Multi-question indicator
    const multiEl = document.getElementById('q-multi');
    if (enc.questions.length > 1) {
      multiEl.textContent = `Q ${state.qIdx + 1} of ${enc.questions.length}`;
      multiEl.classList.add('visible');
    } else {
      multiEl.classList.remove('visible');
    }

    // Prompt
    document.getElementById('q-prompt').textContent = q.prompt;

    // Options
    const grid = document.getElementById('options-grid');
    grid.innerHTML = '';
    ['A','B','C','D'].forEach(letter => {
      if (!q.options[letter]) return;
      const btn = document.createElement('button');
      btn.className = 'option-btn';
      btn.dataset.letter = letter;
      btn.onclick = () => selectAnswer(letter);
      btn.innerHTML = `
        <div class="option-letter">${letter}</div>
        <div class="option-content">
          <div class="option-text">${escapeHtml(q.options[letter])}</div>
        </div>`;
      grid.appendChild(btn);
    });

    // Hide feedback panel
    const fp = document.getElementById('feedback-panel');
    fp.classList.remove('visible');
    document.getElementById('feedback-header').className = 'feedback-header';
    document.getElementById('feedback-header').textContent = '';
    document.getElementById('feedback-explanation').textContent = '';
    document.getElementById('feedback-distractors').innerHTML = '';

    // Next button label
    const isLastQ = state.qIdx >= enc.questions.length - 1;
    const isLastEnc = state.encIdx >= state.pool.length - 1;
    document.getElementById('btn-next-q').textContent =
      isLastQ && isLastEnc ? 'See Results â†’' :
      isLastQ              ? 'Next Encounter â†’' :
                             'Next Question â†’';

    state.answered = false;

    // Re-animate card
    const wrap = document.getElementById('question-wrap');
    wrap.style.animation = 'none';
    wrap.offsetHeight;
    wrap.style.animation = '';
  }

  function selectAnswer(letter) {
    if (state.answered) return;
    state.answered = true;

    const enc = state.pool[state.encIdx];
    const q   = enc.questions[state.qIdx];
    const isCorrect = letter === q.correct_answer;

    // Lock + style options
    document.querySelectorAll('.option-btn').forEach(btn => {
      btn.disabled = true;
      const l = btn.dataset.letter;
      if (l === q.correct_answer)        btn.classList.add('correct');
      else if (l === letter)             btn.classList.add('wrong');
      else                               btn.classList.add('dimmed');
    });

    // Score tracking
    const domain = enc.domain_code;
    state.domainScores[domain] = state.domainScores[domain] || { correct: 0, total: 0 };
    state.domainScores[domain].total++;
    state.typeScores[q.type] = state.typeScores[q.type] || { correct: 0, total: 0 };
    state.typeScores[q.type].total++;
    if (isCorrect) {
      state.domainScores[domain].correct++;
      state.typeScores[q.type].correct++;
    }

    state.sessionAnswers.push({
      encId: enc.id,
      qId:   q.question_id,
      type:  q.type,
      correct: isCorrect,
      domain,
      encLabel: enc.encounter.patient.label,
      subdomain: enc.subdomain,
    });

    showFeedback(q, isCorrect);
  }

  function showFeedback(q, isCorrect) {
    const header = document.getElementById('feedback-header');
    header.className = 'feedback-header ' + (isCorrect ? 'correct' : 'wrong');
    header.innerHTML = isCorrect
      ? '<span>âœ“</span> Correct!'
      : `<span>âœ—</span> Incorrect â€” the correct answer is <strong>${q.correct_answer}</strong>`;

    document.getElementById('feedback-explanation').textContent = q.explanation || '';

    // Distractor rationale
    const dr = q.distractor_rationale || {};
    const distEl = document.getElementById('feedback-distractors');
    distEl.innerHTML = '';
    ['A','B','C','D'].forEach(letter => {
      if (letter === q.correct_answer || !dr[letter]) return;
      const row = document.createElement('div');
      row.className = 'distractor-row';
      row.innerHTML = `<span class="distractor-letter">Why not ${letter}?</span><span class="distractor-text">${escapeHtml(dr[letter])}</span>`;
      distEl.appendChild(row);
    });

    // Slide open feedback panel
    const fp = document.getElementById('feedback-panel');
    fp.classList.add('visible');

    // Scroll to show feedback
    fp.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  function nextQuestion() {
    const enc = state.pool[state.encIdx];
    state.qIdx++;
    if (state.qIdx < enc.questions.length) {
      renderQuestion(enc.questions[state.qIdx]);
    } else {
      nextEncounter();
    }
  }

  function nextEncounter() {
    state.encIdx++;
    state.qIdx = 0;
    _tagSlotIdx = 0;  // reset tag positioning
    if (state.encIdx >= state.pool.length) {
      persistScores();
      showScreen('results');
      buildResults();
    } else {
      showScreen('encounter');
      startEncounter(state.pool[state.encIdx]);
    }
  }

  function reviewEncounter() {
    // Show the encounter in read-only mode (all phases complete)
    state.reviewMode = true;
    const enc = state.pool[state.encIdx];
    showScreen('encounter');

    // Rebuild chart with ALL reveals immediately (no animation)
    buildChartSections(enc);
    const chartBody = document.getElementById('chart-body');
    enc.encounter.phases.forEach(phase => {
      (phase.chart_reveals || []).forEach(item => {
        const secId = 'chart-sec-' + item.category.replace(/[^a-zA-Z0-9]/g, '-');
        const sec = document.getElementById(secId);
        if (!sec) return;
        const row = document.createElement('div');
        row.className = 'chart-row';
        row.style.opacity = '1';
        row.style.animation = 'none';
        row.innerHTML = `<span class="chart-key">${escapeHtml(item.label)}</span><span class="chart-val">${escapeHtml(item.value)}</span>`;
        sec.appendChild(row);
      });
    });

    // Show last phase dialogue, all tags
    document.getElementById('tag-overlay').innerHTML = '';
    _tagSlotIdx = 0;
    enc.encounter.phases.forEach(phase => {
      (phase.behavioral_tags || []).forEach((tag, idx) => {
        const el = document.createElement('span');
        el.className = 'behavior-tag ' + getTagColor(tag);
        el.textContent = tag;
        el.style.opacity = '1';
        el.style.animation = 'none';
        const pos = TAG_POSITIONS[_tagSlotIdx % TAG_POSITIONS.length];
        _tagSlotIdx++;
        Object.assign(el.style, pos);
        document.getElementById('tag-overlay').appendChild(el);
      });
    });

    // Patient info
    document.getElementById('patient-label').textContent   = enc.encounter.patient.label;
    document.getElementById('patient-setting').textContent = enc.encounter.setting;

    // Last phase label + all dots done
    const lastPhase = enc.encounter.phases[enc.encounter.phases.length - 1];
    document.getElementById('phase-label').textContent = lastPhase.phase_label;
    buildPhaseDots(enc.encounter.phases.length);
    enc.encounter.phases.forEach((_, i) => {
      const dot = document.getElementById(`phase-dot-${i}`);
      if (dot) dot.className = 'phase-dot done';
    });

    // Last phase dialogue shown statically
    document.getElementById('bubble-text').textContent = lastPhase.dialogue || '';
    document.getElementById('speech-bubble').classList.remove('hidden');
    document.getElementById('bubble-dots').classList.add('hidden');

    // Avatar at last-phase emotion
    setAvatarState(lastPhase.avatar_emotion || 'idle');

    // Replace advance button with "Return to Question"
    const advBtn = document.getElementById('btn-advance');
    advBtn.textContent = 'â† Return to Question';
    advBtn.classList.remove('hidden');
    advBtn.onclick = () => {
      advBtn.textContent = 'Next â†’';
      advBtn.onclick = advancePhase;
      state.reviewMode = false;
      showScreen('question');
      renderQuestion(state.pool[state.encIdx].questions[state.qIdx]);
    };
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     RESULTS  (Chunk 6 adds full ring animation + replay list)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function buildResults() {
    const answers = state.sessionAnswers;
    const total   = answers.length;
    const correct = answers.filter(a => a.correct).length;
    const pct     = total ? Math.round((correct / total) * 100) : 0;

    // Heading
    const heading = document.getElementById('results-heading');
    if (pct >= 80)      heading.innerHTML = 'Great <em>Work!</em>';
    else if (pct >= 60) heading.innerHTML = 'Session <em>Complete</em>';
    else                heading.innerHTML = 'Keep <em>Practicing</em>';

    // Score ring animation
    const ring  = document.getElementById('ring-fill');
    const circ  = 2 * Math.PI * 52;
    const offset = circ * (1 - pct / 100);
    ring.style.stroke = pct >= 70 ? 'var(--accent)' : pct >= 50 ? 'var(--orange)' : 'var(--red)';
    setTimeout(() => {
      ring.style.transition = 'stroke-dashoffset 1.2s cubic-bezier(.4,0,.2,1)';
      ring.style.strokeDashoffset = offset;
    }, 100);

    // Animate pct counter
    const pctEl = document.getElementById('ring-pct');
    pctEl.style.color = pct >= 70 ? 'var(--accent-light)' : pct >= 50 ? 'var(--orange)' : 'var(--red)';
    let cur = 0;
    const step = pct / 60;
    const intv = setInterval(() => {
      cur = Math.min(cur + step, pct);
      pctEl.textContent = Math.round(cur) + '%';
      if (cur >= pct) clearInterval(intv);
    }, 16);

    // Summary stats
    const domainsUsed = [...new Set(answers.map(a => a.domain))];
    document.getElementById('results-summary').innerHTML = `
      <div class="rs-item"><span class="rs-label">Score</span><span class="rs-val">${pct}%</span></div>
      <div class="rs-item"><span class="rs-label">Correct</span><span class="rs-val">${correct}/${total}</span></div>
      <div class="rs-item"><span class="rs-label">Encounters</span><span class="rs-val">${state.pool.length}</span></div>
      <div class="rs-item"><span class="rs-label">Domains</span><span class="rs-val">${domainsUsed.length}</span></div>
    `;

    // Type breakdown
    const typeRows = document.getElementById('type-rows');
    typeRows.innerHTML = '';
    Object.entries(state.typeScores).forEach(([type, s]) => {
      if (!s.total) return;
      const conf  = TYPE_BADGE[type] || { label: type, color: '#6366f1' };
      const tPct  = Math.round((s.correct / s.total) * 100);
      const row   = document.createElement('div');
      row.className = 'type-row-item';
      row.innerHTML = `
        <span class="type-badge-sm" style="color:${conf.color};background:${conf.color}1a;border-color:${conf.color}44">${conf.label}</span>
        <div class="type-bar-track"><div class="type-bar-fill" style="background:${conf.color}" data-pct="${tPct}"></div></div>
        <span class="type-fraction">${s.correct}/${s.total}</span>`;
      typeRows.appendChild(row);
    });
    setTimeout(() => {
      typeRows.querySelectorAll('.type-bar-fill').forEach(el => el.style.width = el.dataset.pct + '%');
    }, 200);

    // Domain breakdown
    const domRows = document.getElementById('domain-rows');
    domRows.innerHTML = '';
    domainsUsed.sort().forEach(d => {
      const s  = state.domainScores[d] || { correct: 0, total: 0 };
      const dp = s.total ? Math.round((s.correct / s.total) * 100) : 0;
      const cls = dp >= 75 ? 'high' : dp >= 50 ? 'mid' : 'low';
      const row = document.createElement('div');
      row.className = 'db-row';
      row.innerHTML = `
        <span class="db-domain">${d}</span>
        <div class="db-track"><div class="db-fill ${cls}" data-pct="${dp}"></div></div>
        <span class="db-score">${s.correct}/${s.total}</span>`;
      domRows.appendChild(row);
    });
    setTimeout(() => {
      domRows.querySelectorAll('.db-fill').forEach(el => el.style.width = el.dataset.pct + '%');
    }, 200);

    // Encounter replay list
    // Group answers by encounter
    const encMap = {};
    answers.forEach(a => {
      if (!encMap[a.encId]) encMap[a.encId] = { label: a.encLabel, domain: a.domain, subdomain: a.subdomain, correct: 0, total: 0, encIdx: null };
      encMap[a.encId].total++;
      if (a.correct) encMap[a.encId].correct++;
    });
    state.pool.forEach((enc, idx) => {
      if (encMap[enc.id]) encMap[enc.id].encIdx = idx;
    });

    const replayList = document.getElementById('replay-list');
    replayList.innerHTML = '';
    Object.entries(encMap).forEach(([encId, info]) => {
      const allCorrect = info.correct === info.total;
      const row = document.createElement('div');
      row.className = 'replay-row';
      row.innerHTML = `
        <span class="replay-outcome ${allCorrect ? 'correct' : 'wrong'}">${allCorrect ? 'âœ“' : 'âœ—'}</span>
        <span class="replay-label">${escapeHtml(info.label || 'â€”')} â€” ${escapeHtml(info.subdomain || 'â€”')}</span>
        <span class="replay-domain">${escapeHtml(info.domain)}</span>
        <button class="btn-replay" onclick="replayEncounter(${info.encIdx})">Review</button>`;
      replayList.appendChild(row);
    });
  }

  function replayEncounter(idx) {
    if (idx === null || idx < 0) return;
    state.encIdx = idx;
    state.qIdx   = 0;
    reviewEncounter();
  }

  function newSession()   { location.href = 'clinical-presentation-settings.html'; }
  function retrySession() { location.reload(); }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BOOT
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  loadEncounters().catch(err => {
    showError('Error loading encounters: ' + err.message);
    console.error('[boot]', err);
  });
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     DEV: AVATAR STATE CYCLER (visible when ?dev=1)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  (function initDevPanel() {
    const sp = new URLSearchParams(location.search);
    if (sp.get('dev') !== '1') return;

    const STATES = [
      'idle','speaking','flat_affect','distressed','tearful',
      'anxious','agitated','guarded','hopeful','confused'
    ];
    let devIdx = 0;

    const panel = document.getElementById('dev-panel');
    if (!panel) return;
    panel.style.display = 'flex';

    document.getElementById('dev-state-label').textContent = STATES[devIdx];

    document.getElementById('dev-prev').addEventListener('click', () => {
      devIdx = (devIdx - 1 + STATES.length) % STATES.length;
      applyDevState();
    });
    document.getElementById('dev-next').addEventListener('click', () => {
      devIdx = (devIdx + 1) % STATES.length;
      applyDevState();
    });

    function applyDevState() {
      const s = STATES[devIdx];
      document.getElementById('dev-state-label').textContent = s;
      setAvatarState(s);
      // Reset tear group opacity so CSS animation takes over when tearful
      const tearGroup = document.getElementById('avatar-tear');
      if (tearGroup) tearGroup.style.animation = '';
    }
  })();
  </script>

  <!-- Dev avatar state cycler panel (shown only when ?dev=1) -->
  <div id="dev-panel" style="
    display:none; position:fixed; bottom:20px; left:50%;
    transform:translateX(-50%);
    background:rgba(20,20,35,0.95); border:1px solid #6366f1;
    border-radius:12px; padding:10px 20px;
    align-items:center; gap:16px;
    font-family:inherit; color:#e2e8f0; font-size:13px;
    z-index:9999; box-shadow:0 4px 20px rgba(0,0,0,0.5);
    user-select:none;">
    <span style="color:#818cf8;font-weight:700;font-size:11px;letter-spacing:.1em;text-transform:uppercase;">DEV â€” Avatar State</span>
    <button id="dev-prev" style="
      background:#4f46e5; border:none; border-radius:6px;
      color:#fff; font-size:16px; width:28px; height:28px;
      cursor:pointer; display:flex; align-items:center; justify-content:center;">â€¹</button>
    <span id="dev-state-label" style="min-width:90px;text-align:center;font-weight:600;color:#c7d2fe;"></span>
    <button id="dev-next" style="
      background:#4f46e5; border:none; border-radius:6px;
      color:#fff; font-size:16px; width:28px; height:28px;
      cursor:pointer; display:flex; align-items:center; justify-content:center;">â€º</button>
  </div>

</body>
</html>
